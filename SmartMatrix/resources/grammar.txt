PROGRAM->DECLARE_FUNC FUNCTION
DECLARE_FUNC->SIMPLETYPE identifier ( LISTPARAM ) ; DECLARE_FUNC
DECLARE_FUNC->matrix identifier ( LISTPARAM ) ; DECLARE_FUNC
DECLARE_FUNC->void DECLARE_AFTER_VOID
DECLARE_AFTER_VOID->identifier ( LISTPARAM ) ; DECLARE_FUNC
DECLARE_AFTER_VOID->MAIN
TYPE->SIMPLETYPE
TYPE->void
SIMPLETYPE->double
SIMPLETYPE->integer
SIMPLETYPE->string
SIMPLETYPE->bool
MAIN->main ( ) { CODE }
FUNCTION->TYPE identifier ( LISTPARAM ) { CODE } FUNCTION
FUNCTION->matrix identifier ( LISTPARAM ) { CODE } FUNCTION
LISTPARAM->TYPE_PARAM identifier NEXT_PARAM
LISTPARAM->eps
TYPE_PARAM->SIMPLETYPE
TYPE_PARAM->matrix
NEXT_PARAM->, TYPE_PARAM identifier NEXT_PARAM
NEXT_PARAM->eps
CODE->identifier CONTEXT_IDENTIFIER ; CODE
CODE->IF CODE
CODE->FOR CODE
CODE->OPERATION_ASIGN ; CODE
CODE->return VALUE ; CODE
CODE->eps
CONTEXT_IDENTIFIER->ASSIGN_ELEM_MATR
CONTEXT_IDENTIFIER->FUNC_CALL_PARAMS
CONTEXT_IDENTIFIER->ASIGN_USUAL
ASSIGN_ELEM_MATR->ACCESS_ELEM_MATR = INIT_ELEM_MATR
INIT_ELEM_MATR->literal
INIT_ELEM_MATR->identifier ACCESS_ELEM_MATR
ACCESS_ELEM_MATR->[ DIGIT , DIGIT ]
DIGIT->identifier
DIGIT->literal
FUNC_CALL_PARAMS->( PASSED_ARGS )
PASSED_ARGS->ARGUMENT PAS_ARGS
PASSED_ARGS->eps
PAS_ARGS->, ARGUMENT PAS_ARGS
PAS_ARGS->eps
ARGUMENT->identifier COMPOSITE_PART
ARGUMENT->literal
COMPOSITE_PART->ACCESS_MATR
COMPOSITE_PART->FUNC_CALL_PARAMS
COMPOSITE_PART->eps
ACCESS_MATR->[ DIGIT , DIGIT ]
ASIGN_USUAL->= EXPRESSION
EXPRESSION->ARITHMETIC_EXPRESSION
EXPRESSION->DETERMINANT
EXPRESSION->TRANSPONATION
ARITHMETIC_EXPRESSION->PART_DIGIT_TERM ADD_PART_DIGIT_TERM
PART_DIGIT_TERM->( ARITHMETIC_EXPRESSION )
PART_DIGIT_TERM->identifier AFTER_IDENTIFIER
PART_DIGIT_TERM->literal
PART_DIGIT_TERM->true
PART_DIGIT_TERM->false
AFTER_IDENTIFIER->ACCESS_MATR
AFTER_IDENTIFIER->FUNC_CALL_PARAMS
AFTER_IDENTIFIER->eps
ADD_PART_DIGIT_TERM->SIGN PART_DIGIT_TERM ADD_PART_DIGIT_TERM
ADD_PART_DIGIT_TERM->eps
SIGN->*
SIGN->/
SIGN->+
SIGN->-
SIGN->%
DETERMINANT->det ( INIT_MATR )
TRANSPONATION->transp ( INIT_MATR )
INIT_MATR->{ ROW NEXT_ROWS }
INIT_MATR->identifier
ROW->{ DIGIT NEXT_DIGITS }
ROW->eps
NEXT_DIGITS->, DIGIT NEXT_DIGITS
NEXT_DIGITS->eps
NEXT_ROWS->, ROW NEXT_ROWS
NEXT_ROWS->eps
IF->if ( LOGICAL_EXPRESSION ) { CODE } ELSE
LOGICAL_EXPRESSION->LOGICAL_TERM
LOGICAL_TERM->PART_LOGTERM ADD_PART_LOGTERM
PART_LOGTERM->ARITHMETIC_EXPRESSION OP_COMPARE
ADD_PART_LOGTERM->LOG_COMPARE PART_LOGTERM ADD_PART_LOGTERM
ADD_PART_LOGTERM->eps
OP_COMPARE->COMPARE ARITHMETIC_EXPRESSION
COMPARE-><
COMPARE->>
COMPARE->==
COMPARE->!=
COMPARE-><=
COMPARE->>=
LOG_COMPARE->&&
LOG_COMPARE->||
ELSE->else { CODE }
ELSE->eps
FOR->for ( INIT_BLOCK ; CONDITION_BLOCK ; ITERATION_BLOCK ) { CODE }
INIT_BLOCK->identifier ASIGN_USUAL NEXT_ASIGN_USUAL
INIT_BLOCK->eps
NEXT_ASIGN_USUAL->, identifier ASIGN_USUAL NEXT_ASIGN_USUAL
NEXT_ASIGN_USUAL->eps
CONDITION_BLOCK->LOGICAL_EXPRESSION NEXT_LOGICAL_EXPRESSION
CONDITION_BLOCK->eps
NEXT_LOGICAL_EXPRESSION->, LOGICAL_EXPRESSION NEXT_LOGICAL_EXPRESSION
NEXT_LOGICAL_EXPRESSION->eps
ITERATION_BLOCK->identifier ASIGN_USUAL NEXT_ASIGN_BLOCK
ITERATION_BLOCK->eps
NEXT_ASIGN_BLOCK->, ASIGN_USUAL NEXT_ASIGN_BLOCK
NEXT_ASIGN_BLOCK->eps
OPERATION_ASIGN->matrix ACCESS_MATR identifier = INIT_MATR
OPERATION_ASIGN->SIMPLETYPE identifier = EXPRESSION
RETURN_FROM_FUNC->VALUE
VALUE->EXPRESSION
